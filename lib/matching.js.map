{
  "version": 3,
  "file": "matching.js",
  "sourceRoot": "../",
  "sources": [
    "src/matching.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "frequency_lists = require('./frequency_lists')\nadjacency_graphs = require('./adjacency_graphs')\nscoring = require('./scoring')\n\nbuild_ranked_dict = (ordered_list) ->\n  result = {}\n  i = 1 # rank starts at 1, not 0\n  for word in ordered_list\n    result[word] = i\n    i += 1\n  result\n\nRANKED_DICTIONARIES = {}\nfor name, lst of frequency_lists\n  RANKED_DICTIONARIES[name] = build_ranked_dict lst\n\nGRAPHS =\n  qwerty:     adjacency_graphs.qwerty\n  dvorak:     adjacency_graphs.dvorak\n  keypad:     adjacency_graphs.keypad\n  mac_keypad: adjacency_graphs.mac_keypad\n\nL33T_TABLE =\n  a: ['4', '@']\n  b: ['8']\n  c: ['(', '{', '[', '<']\n  e: ['3']\n  g: ['6', '9']\n  i: ['1', '!', '|']\n  l: ['1', '|', '7']\n  o: ['0']\n  s: ['$', '5']\n  t: ['+', '7']\n  x: ['%']\n  z: ['2']\n\nREGEXEN =\n  recent_year:  /19\\d\\d|200\\d|201\\d/g\n\nDATE_MAX_YEAR = 2050\nDATE_MIN_YEAR = 1000\nDATE_SPLITS =\n  4:[      # for length-4 strings, eg 1191 or 9111, two ways to split:\n    [1, 2] # 1 1 91 (2nd split starts at index 1, 3rd at index 2)\n    [2, 3] # 91 1 1\n    ]\n  5:[\n    [1, 3] # 1 11 91\n    [2, 3] # 11 1 91\n    ]\n  6:[\n    [1, 2] # 1 1 1991\n    [2, 4] # 11 11 91\n    [4, 5] # 1991 1 1\n    ]\n  7:[\n    [1, 3] # 1 11 1991\n    [2, 3] # 11 1 1991\n    [4, 5] # 1991 1 11\n    [4, 6] # 1991 11 1\n    ]\n  8:[\n    [2, 4] # 11 11 1991\n    [4, 6] # 1991 11 11\n    ]\n\nmatching =\n  empty: (obj) -> (k for k of obj).length == 0\n  extend: (lst, lst2) -> lst.push.apply lst, lst2\n  translate: (string, chr_map) -> (chr_map[chr] or chr for chr in string.split('')).join('')\n  mod: (n, m) -> ((n % m) + m) % m # mod impl that works for negative numbers\n  sorted: (matches) ->\n    # sort on i primary, j secondary\n    matches.sort (m1, m2) ->\n      (m1.i - m2.i) or (m1.j - m2.j)\n\n  # ------------------------------------------------------------------------------\n  # omnimatch -- combine everything ----------------------------------------------\n  # ------------------------------------------------------------------------------\n\n  omnimatch: (password) ->\n    matches = []\n    matchers = [\n      @dictionary_match\n      @reverse_dictionary_match\n      @l33t_match\n      @spatial_match\n      @repeat_match\n      @sequence_match\n      @regex_match\n      @date_match\n    ]\n    for matcher in matchers\n      @extend matches, matcher.call(this, password)\n    @sorted matches\n\n  #-------------------------------------------------------------------------------\n  # dictionary match (common passwords, english, last names, etc) ----------------\n  #-------------------------------------------------------------------------------\n\n  dictionary_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES) ->\n    # _ranked_dictionaries variable is for unit testing purposes\n    matches = []\n    len = password.length\n    password_lower = password.toLowerCase()\n    for dictionary_name, ranked_dict of _ranked_dictionaries\n      for i in [0...len]\n        for j in [i...len]\n          if password_lower[i..j] of ranked_dict\n            word = password_lower[i..j]\n            rank = ranked_dict[word]\n            matches.push\n              pattern: 'dictionary'\n              i: i\n              j: j\n              token: password[i..j]\n              matched_word: word\n              rank: rank\n              dictionary_name: dictionary_name\n              reversed: false\n              l33t: false\n    @sorted matches\n\n  reverse_dictionary_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES) ->\n    reversed_password = password.split('').reverse().join('')\n    matches = @dictionary_match reversed_password, _ranked_dictionaries\n    for match in matches\n      match.token = match.token.split('').reverse().join('') # reverse back\n      match.reversed = true\n      # map coordinates back to original string\n      [match.i, match.j] = [\n        password.length - 1 - match.j\n        password.length - 1 - match.i\n      ]\n    @sorted matches\n\n  set_user_input_dictionary: (ordered_list) ->\n    RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict ordered_list.slice()\n\n  #-------------------------------------------------------------------------------\n  # dictionary match with common l33t substitutions ------------------------------\n  #-------------------------------------------------------------------------------\n\n  # makes a pruned copy of l33t_table that only includes password's possible substitutions\n  relevant_l33t_subtable: (password, table) ->\n    password_chars = {}\n    for chr in password.split('')\n      password_chars[chr] = true\n    subtable = {}\n    for letter, subs of table\n      relevant_subs = (sub for sub in subs when sub of password_chars)\n      if relevant_subs.length > 0\n        subtable[letter] = relevant_subs\n    subtable\n\n  # returns the list of possible 1337 replacement dictionaries for a given password\n  enumerate_l33t_subs: (table) ->\n    keys = (k for k of table)\n    subs = [[]]\n\n    dedup = (subs) ->\n      deduped = []\n      members = {}\n      for sub in subs\n        assoc = ([k,v] for k,v in sub)\n        assoc.sort()\n        label = (k+','+v for k,v in assoc).join('-')\n        unless label of members\n          members[label] = true\n          deduped.push sub\n      deduped\n\n    helper = (keys) ->\n      return if not keys.length\n      first_key = keys[0]\n      rest_keys = keys[1..]\n      next_subs = []\n      for l33t_chr in table[first_key]\n        for sub in subs\n          dup_l33t_index = -1\n          for i in [0...sub.length]\n            if sub[i][0] == l33t_chr\n              dup_l33t_index = i\n              break\n          if dup_l33t_index == -1\n            sub_extension = sub.concat [[l33t_chr, first_key]]\n            next_subs.push sub_extension\n          else\n            sub_alternative = sub.slice(0)\n            sub_alternative.splice(dup_l33t_index, 1)\n            sub_alternative.push [l33t_chr, first_key]\n            next_subs.push sub\n            next_subs.push sub_alternative\n      subs = dedup next_subs\n      helper(rest_keys)\n\n    helper(keys)\n    sub_dicts = [] # convert from assoc lists to dicts\n    for sub in subs\n      sub_dict = {}\n      for [l33t_chr, chr] in sub\n        sub_dict[l33t_chr] = chr\n      sub_dicts.push sub_dict\n    sub_dicts\n\n  l33t_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES, _l33t_table = L33T_TABLE) ->\n    matches = []\n    for sub in @enumerate_l33t_subs @relevant_l33t_subtable(password, _l33t_table)\n      break if @empty sub # corner case: password has no relevant subs.\n      subbed_password = @translate password, sub\n      for match in @dictionary_match(subbed_password, _ranked_dictionaries)\n        token = password[match.i..match.j]\n        if token.toLowerCase() == match.matched_word\n          continue # only return the matches that contain an actual substitution\n        match_sub = {} # subset of mappings in sub that are in use for this match\n        for subbed_chr, chr of sub when token.indexOf(subbed_chr) != -1\n          match_sub[subbed_chr] = chr\n        match.l33t = true\n        match.token = token\n        match.sub = match_sub\n        match.sub_display = (\"#{k} -> #{v}\" for k,v of match_sub).join(', ')\n        matches.push match\n    @sorted matches.filter (match) ->\n      # filter single-character l33t matches to reduce noise.\n      # otherwise '1' matches 'i', '4' matches 'a', both very common English words\n      # with low dictionary rank.\n      match.token.length > 1\n\n  # ------------------------------------------------------------------------------\n  # spatial match (qwerty/dvorak/keypad) -----------------------------------------\n  # ------------------------------------------------------------------------------\n\n  spatial_match: (password, _graphs = GRAPHS) ->\n    matches = []\n    for graph_name, graph of _graphs\n      @extend matches, @spatial_match_helper(password, graph, graph_name)\n    @sorted matches\n\n  SHIFTED_RX: /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/\n  spatial_match_helper: (password, graph, graph_name) ->\n    matches = []\n    i = 0\n    while i < password.length - 1\n      j = i + 1\n      last_direction = null\n      turns = 0\n      if graph_name in ['qwerty', 'dvorak'] and @SHIFTED_RX.exec(password.charAt(i))\n        # initial character is shifted\n        shifted_count = 1\n      else\n        shifted_count = 0\n      loop\n        prev_char = password.charAt(j-1)\n        found = false\n        found_direction = -1\n        cur_direction = -1\n        adjacents = graph[prev_char] or []\n        # consider growing pattern by one character if j hasn't gone over the edge.\n        if j < password.length\n          cur_char = password.charAt(j)\n          for adj in adjacents\n            cur_direction += 1\n            if adj and adj.indexOf(cur_char) != -1\n              found = true\n              found_direction = cur_direction\n              if adj.indexOf(cur_char) == 1\n                # index 1 in the adjacency means the key is shifted,\n                # 0 means unshifted: A vs a, % vs 5, etc.\n                # for example, 'q' is adjacent to the entry '2@'.\n                # @ is shifted w/ index 1, 2 is unshifted.\n                shifted_count += 1\n              if last_direction != found_direction\n                # adding a turn is correct even in the initial case when last_direction is null:\n                # every spatial pattern starts with a turn.\n                turns += 1\n                last_direction = found_direction\n              break\n        # if the current pattern continued, extend j and try to grow again\n        if found\n          j += 1\n        # otherwise push the pattern discovered so far, if any...\n        else\n          if j - i > 2 # don't consider length 1 or 2 chains.\n            matches.push\n              pattern: 'spatial'\n              i: i\n              j: j-1\n              token: password[i...j]\n              graph: graph_name\n              turns: turns\n              shifted_count: shifted_count\n          # ...and then start a new search for the rest of the password.\n          i = j\n          break\n    matches\n\n  #-------------------------------------------------------------------------------\n  # repeats (aaa, abcabcabc) and sequences (abcdef) ------------------------------\n  #-------------------------------------------------------------------------------\n\n  repeat_match: (password) ->\n    matches = []\n    greedy = /(.+)\\1+/g\n    lazy = /(.+?)\\1+/g\n    lazy_anchored = /^(.+?)\\1+$/\n    lastIndex = 0\n    while lastIndex < password.length\n      greedy.lastIndex = lazy.lastIndex = lastIndex\n      greedy_match = greedy.exec password\n      lazy_match = lazy.exec password\n      break unless greedy_match?\n      if greedy_match[0].length > lazy_match[0].length\n        # greedy beats lazy for 'aabaab'\n        #   greedy: [aabaab, aab]\n        #   lazy:   [aa,     a]\n        match = greedy_match\n        # greedy's repeated string might itself be repeated, eg.\n        # aabaab in aabaabaabaab.\n        # run an anchored lazy match on greedy's repeated string\n        # to find the shortest repeated string\n        base_token = lazy_anchored.exec(match[0])[1]\n      else\n        # lazy beats greedy for 'aaaaa'\n        #   greedy: [aaaa,  aa]\n        #   lazy:   [aaaaa, a]\n        match = lazy_match\n        base_token = match[1]\n      [i, j] = [match.index, match.index + match[0].length - 1]\n      # recursively match and score the base string\n      base_analysis = scoring.most_guessable_match_sequence(\n        base_token\n        @omnimatch base_token\n      )\n      base_matches = base_analysis.sequence\n      base_guesses = base_analysis.guesses\n      matches.push\n        pattern: 'repeat'\n        i: i\n        j: j\n        token: match[0]\n        base_token: base_token\n        base_guesses: base_guesses\n        base_matches: base_matches\n        repeat_count: match[0].length / base_token.length\n      lastIndex = j + 1\n    matches\n\n  MAX_DELTA: 5\n  sequence_match: (password) ->\n    # Identifies sequences by looking for repeated differences in unicode codepoint.\n    # this allows skipping, such as 9753, and also matches some extended unicode sequences\n    # such as Greek and Cyrillic alphabets.\n    #\n    # for example, consider the input 'abcdb975zy'\n    #\n    # password: a   b   c   d   b    9   7   5   z   y\n    # index:    0   1   2   3   4    5   6   7   8   9\n    # delta:      1   1   1  -2  -41  -2  -2  69   1\n    #\n    # expected result:\n    # [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n\n    return [] if password.length == 1\n\n    update = (i, j, delta) =>\n      if j - i > 1 or Math.abs(delta) == 1\n        if 0 < Math.abs(delta) <= @MAX_DELTA\n          token = password[i..j]\n          if /^[a-z]+$/.test(token)\n            sequence_name = 'lower'\n            sequence_space = 26\n          else if /^[A-Z]+$/.test(token)\n            sequence_name = 'upper'\n            sequence_space = 26\n          else if /^\\d+$/.test(token)\n            sequence_name = 'digits'\n            sequence_space = 10\n          else\n            # conservatively stick with roman alphabet size.\n            # (this could be improved)\n            sequence_name = 'unicode'\n            sequence_space = 26\n          result.push\n            pattern: 'sequence'\n            i: i\n            j: j\n            token: password[i..j]\n            sequence_name: sequence_name\n            sequence_space: sequence_space\n            ascending: delta > 0\n\n    result = []\n    i = 0\n    last_delta = null\n\n    for k in [1...password.length]\n      delta = password.charCodeAt(k) - password.charCodeAt(k - 1)\n      unless last_delta?\n        last_delta = delta\n      continue if delta == last_delta\n      j = k - 1\n      update(i, j, last_delta)\n      i = j\n      last_delta = delta\n    update(i, password.length - 1, last_delta)\n    result\n\n  #-------------------------------------------------------------------------------\n  # regex matching ---------------------------------------------------------------\n  #-------------------------------------------------------------------------------\n\n  regex_match: (password, _regexen = REGEXEN) ->\n    matches = []\n    for name, regex of _regexen\n      regex.lastIndex = 0 # keeps regex_match stateless\n      while rx_match = regex.exec password\n        token = rx_match[0]\n        matches.push\n          pattern: 'regex'\n          token: token\n          i: rx_match.index\n          j: rx_match.index + rx_match[0].length - 1\n          regex_name: name\n          regex_match: rx_match\n    @sorted matches\n\n  #-------------------------------------------------------------------------------\n  # date matching ----------------------------------------------------------------\n  #-------------------------------------------------------------------------------\n\n  date_match: (password) ->\n    # a \"date\" is recognized as:\n    #   any 3-tuple that starts or ends with a 2- or 4-digit year,\n    #   with 2 or 0 separator chars (1.1.91 or 1191),\n    #   maybe zero-padded (01-01-91 vs 1-1-91),\n    #   a month between 1 and 12,\n    #   a day between 1 and 31.\n    #\n    # note: this isn't true date parsing in that \"feb 31st\" is allowed,\n    # this doesn't check for leap years, etc.\n    #\n    # recipe:\n    # start with regex to find maybe-dates, then attempt to map the integers\n    # onto month-day-year to filter the maybe-dates into dates.\n    # finally, remove matches that are substrings of other matches to reduce noise.\n    #\n    # note: instead of using a lazy or greedy regex to find many dates over the full string,\n    # this uses a ^...$ regex against every substring of the password -- less performant but leads\n    # to every possible date match.\n    matches = []\n    maybe_date_no_separator = /^\\d{4,8}$/\n    maybe_date_with_separator = ///\n      ^\n      ( \\d{1,4} )    # day, month, year\n      ( [\\s/\\\\_.-] ) # separator\n      ( \\d{1,2} )    # day, month\n      \\2             # same separator\n      ( \\d{1,4} )    # day, month, year\n      $\n    ///\n\n    # dates without separators are between length 4 '1191' and 8 '11111991'\n    for i in [0..password.length - 4]\n      for j in [i + 3..i + 7]\n        break if j >= password.length\n        token = password[i..j]\n        continue unless maybe_date_no_separator.exec token\n        candidates = []\n        for [k,l] in DATE_SPLITS[token.length]\n          dmy = @map_ints_to_dmy [\n            parseInt token[0...k]\n            parseInt token[k...l]\n            parseInt token[l...]\n          ]\n          candidates.push dmy if dmy?\n        continue unless candidates.length > 0\n        # at this point: different possible dmy mappings for the same i,j substring.\n        # match the candidate date that likely takes the fewest guesses: a year closest to 2000.\n        # (scoring.REFERENCE_YEAR).\n        #\n        # ie, considering '111504', prefer 11-15-04 to 1-1-1504\n        # (interpreting '04' as 2004)\n        best_candidate = candidates[0]\n        metric = (candidate) -> Math.abs candidate.year - scoring.REFERENCE_YEAR\n        min_distance = metric candidates[0]\n        for candidate in candidates[1..]\n          distance = metric candidate\n          if distance < min_distance\n            [best_candidate, min_distance] = [candidate, distance]\n        matches.push\n          pattern: 'date'\n          token: token\n          i: i\n          j: j\n          separator: ''\n          year: best_candidate.year\n          month: best_candidate.month\n          day: best_candidate.day\n\n    # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n    for i in [0..password.length - 6]\n      for j in [i + 5..i + 9]\n        break if j >= password.length\n        token = password[i..j]\n        rx_match = maybe_date_with_separator.exec token\n        continue unless rx_match?\n        dmy = @map_ints_to_dmy [\n          parseInt rx_match[1]\n          parseInt rx_match[3]\n          parseInt rx_match[4]\n        ]\n        continue unless dmy?\n        matches.push\n          pattern: 'date'\n          token: token\n          i: i\n          j: j\n          separator: rx_match[2]\n          year: dmy.year\n          month: dmy.month\n          day: dmy.day\n\n    # matches now contains all valid date strings in a way that is tricky to capture\n    # with regexes only. while thorough, it will contain some unintuitive noise:\n    #\n    # '2015_06_04', in addition to matching 2015_06_04, will also contain\n    # 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n    #\n    # to reduce noise, remove date matches that are strict substrings of others\n    @sorted matches.filter (match) ->\n      is_submatch = false\n      for other_match in matches\n        continue if match is other_match\n        if other_match.i <= match.i and other_match.j >= match.j\n          is_submatch = true\n          break\n      not is_submatch\n\n  map_ints_to_dmy: (ints) ->\n    # given a 3-tuple, discard if:\n    #   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n    #   middle int is zero\n    #   any int is over the max allowable year\n    #   any int is over two digits but under the min allowable year\n    #   2 ints are over 31, the max allowable day\n    #   2 ints are zero\n    #   all ints are over 12, the max allowable month\n    return if ints[1] > 31 or ints[1] <= 0\n    over_12 = 0\n    over_31 = 0\n    under_1 = 0\n    for int in ints\n      return if 99 < int < DATE_MIN_YEAR or int > DATE_MAX_YEAR\n      over_31 += 1 if int > 31\n      over_12 += 1 if int > 12\n      under_1 += 1 if int <= 0\n    return if over_31 >= 2 or over_12 == 3 or under_1 >= 2\n\n    # first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n    possible_year_splits = [\n      [ints[2], ints[0..1]] # year last\n      [ints[0], ints[1..2]] # year first\n    ]\n    for [y, rest] in possible_year_splits\n      if DATE_MIN_YEAR <= y <= DATE_MAX_YEAR\n        dm = @map_ints_to_dm rest\n        if dm?\n          return {\n            year: y\n            month: dm.month\n            day: dm.day\n          }\n        else\n          # for a candidate that includes a four-digit year,\n          # when the remaining ints don't match to a day and month,\n          # it is not a date.\n          return\n\n    # given no four-digit year, two digit years are the most flexible int to match, so\n    # try to parse a day-month out of ints[0..1] or ints[1..0]\n    for [y, rest] in possible_year_splits\n      dm = @map_ints_to_dm rest\n      if dm?\n        y = @two_to_four_digit_year y\n        return {\n          year: y\n          month: dm.month\n          day: dm.day\n        }\n\n  map_ints_to_dm: (ints) ->\n    for [d, m] in [ints, ints.slice().reverse()]\n      if 1 <= d <= 31 and 1 <= m <= 12\n        return {\n          day: d\n          month: m\n        }\n\n  two_to_four_digit_year: (year) ->\n    if year > 99\n      year\n    else if year > 50\n      # 87 -> 1987\n      year + 1900\n    else\n      # 15 -> 2015\n      year + 2000\n\nmodule.exports = matching\n"
  ]
}