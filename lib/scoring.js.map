{
  "version": 3,
  "file": "scoring.js",
  "sourceRoot": "../",
  "sources": [
    "src/scoring.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "adjacency_graphs = require('./adjacency_graphs')\n\n# on qwerty, 'g' has degree 6, being adjacent to 'ftyhbv'. '\\' has degree 1.\n# this calculates the average over all keys.\ncalc_average_degree = (graph) ->\n  average = 0\n  for key, neighbors of graph\n    average += (n for n in neighbors when n).length\n  average /= (k for k,v of graph).length\n  average\n\nBRUTEFORCE_CARDINALITY = 10\nMIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000\nMIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10\nMIN_SUBMATCH_GUESSES_MULTI_CHAR = 50\n\nscoring =\n  nCk: (n, k) ->\n    # http://blog.plover.com/math/choose.html\n    return 0 if k > n\n    return 1 if k == 0\n    r = 1\n    for d in [1..k]\n      r *= n\n      r /= d\n      n -= 1\n    r\n\n  log10: (n) -> Math.log(n) / Math.log(10) # IE doesn't support Math.log10 :(\n  log2:  (n) -> Math.log(n) / Math.log(2)\n\n  factorial: (n) ->\n    # unoptimized, called only on small n\n    return 1 if n < 2\n    f = 1\n    f *= i for i in [2..n]\n    f\n\n  # ------------------------------------------------------------------------------\n  # search --- most guessable match sequence -------------------------------------\n  # ------------------------------------------------------------------------------\n  #\n  # takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  # minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  # for a length-n password with m candidate matches. l_max is the maximum optimal\n  # sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  # search terminates rapidly.\n  #\n  # the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  # minimizes the following function:\n  #\n  #    g = l! * Product(m.guesses for m in sequence) + D^(l - 1)\n  #\n  # where l is the length of the sequence.\n  #\n  # the factorial term is the number of ways to order l patterns.\n  #\n  # the D^(l-1) term is another length penalty, roughly capturing the idea that an\n  # attacker will try lower-length sequences first before trying length-l sequences.\n  #\n  # for example, consider a sequence that is date-repeat-dictionary.\n  #  - an attacker would need to try other date-repeat-dictionary combinations,\n  #    hence the product term.\n  #  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  #    ..., hence the factorial term.\n  #  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  #    sequences before length-3. assuming at minimum D guesses per pattern type,\n  #    D^(l-1) approximates Sum(D^i for i in [1..l-1]\n  #\n  # ------------------------------------------------------------------------------\n\n  most_guessable_match_sequence: (password, matches, _exclude_additive=false) ->\n\n    n = password.length\n\n    # partition matches into sublists according to ending index j\n    matches_by_j = ([] for _ in [0...n])\n    for m in matches\n      matches_by_j[m.j].push m\n    # small detail: for deterministic output, sort each sublist by i.\n    for lst in matches_by_j\n      lst.sort (m1, m2) -> m1.i - m2.i\n\n    optimal =\n      # optimal.m[k][l] holds final match in the best length-l match sequence covering the\n      # password prefix up to k, inclusive.\n      # if there is no length-l sequence that scores better (fewer guesses) than\n      # a shorter match sequence spanning the same prefix, optimal.m[k][l] is undefined.\n      m:  ({} for _ in [0...n])\n\n      # same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      # optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: ({} for _ in [0...n])\n\n      # same structure as optimal.m -- holds the overall metric.\n      g:  ({} for _ in [0...n])\n\n    # helper: considers whether a length-l sequence ending at match m is better (fewer guesses)\n    # than previously encountered sequences, updating state if so.\n    update = (m, l) =>\n      k = m.j\n      pi = @estimate_guesses m, password\n      if l > 1\n        # we're considering a length-l sequence ending with match m:\n        # obtain the product term in the minimization function by multiplying m's guesses\n        # by the product of the length-(l-1) sequence ending just before m, at m.i - 1.\n        pi *= optimal.pi[m.i - 1][l - 1]\n      # calculate the minimization func\n      g = @factorial(l) * pi\n      unless _exclude_additive\n        g += Math.pow(MIN_GUESSES_BEFORE_GROWING_SEQUENCE, l - 1)\n      # update state if new best.\n      # first see if any competing sequences covering this prefix, with l or fewer matches,\n      # fare better than this sequence. if so, skip it and return.\n      for competing_l, competing_g of optimal.g[k]\n        continue if competing_l > l\n        return if competing_g <= g\n      # this sequence might be part of the final optimal sequence.\n      optimal.g[k][l] = g\n      optimal.m[k][l] = m\n      optimal.pi[k][l] = pi\n\n    # helper: evaluate bruteforce matches ending at k.\n    bruteforce_update = (k) =>\n      # see if a single bruteforce match spanning the k-prefix is optimal.\n      m = make_bruteforce_match(0, k)\n      update(m, 1)\n      for i in [1..k]\n        # generate k bruteforce matches, spanning from (i=1, j=k) up to (i=k, j=k).\n        # see if adding these new matches to any of the sequences in optimal[i-1]\n        # leads to new bests.\n        m = make_bruteforce_match(i, k)\n        for l, last_m of optimal.m[i-1]\n          l = parseInt(l)\n          # corner: an optimal sequence will never have two adjacent bruteforce matches.\n          # it is strictly better to have a single bruteforce match spanning the same region:\n          # same contribution to the guess product with a lower length.\n          # --> safe to skip those cases.\n          continue if last_m.pattern == 'bruteforce'\n          # try adding m to this length-l sequence.\n          update(m, l + 1)\n\n    # helper: make bruteforce match objects spanning i to j, inclusive.\n    make_bruteforce_match = (i, j) =>\n      pattern: 'bruteforce'\n      token: password[i..j]\n      i: i\n      j: j\n\n    # helper: step backwards through optimal.m starting at the end,\n    # constructing the final optimal match sequence.\n    unwind = (n) =>\n      optimal_match_sequence = []\n      k = n - 1\n      # find the final best sequence length and score\n      l = undefined\n      g = Infinity\n      for candidate_l, candidate_g of optimal.g[k]\n        if candidate_g < g\n          l = candidate_l\n          g = candidate_g\n\n      while k >= 0\n        m = optimal.m[k][l]\n        optimal_match_sequence.unshift m\n        k = m.i - 1\n        l--\n      optimal_match_sequence\n\n    for k in [0...n]\n      for m in matches_by_j[k]\n        if m.i > 0\n          for l of optimal.m[m.i - 1]\n            l = parseInt(l)\n            update(m, l + 1)\n        else\n          update(m, 1)\n      bruteforce_update(k)\n    optimal_match_sequence = unwind(n)\n    optimal_l = optimal_match_sequence.length\n\n    # corner: empty password\n    if password.length == 0\n      guesses = 1\n    else\n      guesses = optimal.g[n - 1][optimal_l]\n\n    # final result object\n    password: password\n    guesses: guesses\n    guesses_log10: @log10 guesses\n    sequence: optimal_match_sequence\n\n  # ------------------------------------------------------------------------------\n  # guess estimation -- one function per match pattern ---------------------------\n  # ------------------------------------------------------------------------------\n\n  estimate_guesses: (match, password) ->\n    return match.guesses if match.guesses? # a match's guess estimate doesn't change. cache it.\n    min_guesses = 1\n    if match.token.length < password.length\n      min_guesses = if match.token.length == 1\n        MIN_SUBMATCH_GUESSES_SINGLE_CHAR\n      else\n        MIN_SUBMATCH_GUESSES_MULTI_CHAR\n    estimation_functions =\n      bruteforce: @bruteforce_guesses\n      dictionary: @dictionary_guesses\n      spatial:    @spatial_guesses\n      repeat:     @repeat_guesses\n      sequence:   @sequence_guesses\n      regex:      @regex_guesses\n      date:       @date_guesses\n    guesses = estimation_functions[match.pattern].call this, match\n    match.guesses = Math.max guesses, min_guesses\n    match.guesses_log10 = @log10 match.guesses\n    match.guesses\n\n  bruteforce_guesses: (match) ->\n    guesses = Math.pow BRUTEFORCE_CARDINALITY, match.token.length\n    if guesses == Number.POSITIVE_INFINITY\n        guesses = Number.MAX_VALUE;\n    # small detail: make bruteforce matches at minimum one guess bigger than smallest allowed\n    # submatch guesses, such that non-bruteforce submatches over the same [i..j] take precedence.\n    min_guesses = if match.token.length == 1\n      MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1\n    else\n      MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1\n    Math.max guesses, min_guesses\n\n  repeat_guesses: (match) ->\n    match.base_guesses * match.repeat_count\n\n  sequence_guesses: (match) ->\n    first_chr = match.token.charAt(0)\n    # lower guesses for obvious starting points\n    if first_chr in ['a', 'A', 'z', 'Z', '0', '1', '9']\n      base_guesses = 4\n    else\n      if first_chr.match /\\d/\n        base_guesses = 10 # digits\n      else\n        # could give a higher base for uppercase,\n        # assigning 26 to both upper and lower sequences is more conservative.\n        base_guesses = 26\n    if not match.ascending\n      # need to try a descending sequence in addition to every ascending sequence ->\n      # 2x guesses\n      base_guesses *= 2\n    base_guesses * match.token.length\n\n  MIN_YEAR_SPACE: 20\n  REFERENCE_YEAR: new Date().getFullYear()\n\n  regex_guesses: (match) ->\n    char_class_bases =\n      alpha_lower:  26\n      alpha_upper:  26\n      alpha:        52\n      alphanumeric: 62\n      digits:       10\n      symbols:      33\n    if match.regex_name of char_class_bases\n      Math.pow(char_class_bases[match.regex_name], match.token.length)\n    else switch match.regex_name\n      when 'recent_year'\n        # conservative estimate of year space: num years from REFERENCE_YEAR.\n        # if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n        year_space = Math.abs parseInt(match.regex_match[0]) - @REFERENCE_YEAR\n        year_space = Math.max year_space, @MIN_YEAR_SPACE\n        year_space\n\n  date_guesses: (match) ->\n    # base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n    year_space = Math.max(Math.abs(match.year - @REFERENCE_YEAR), @MIN_YEAR_SPACE)\n    guesses = year_space * 365\n    # add factor of 4 for separator selection (one of ~4 choices)\n    guesses *= 4 if match.separator\n    guesses\n\n  KEYBOARD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.qwerty)\n  # slightly different for keypad/mac keypad, but close enough\n  KEYPAD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.keypad)\n\n  KEYBOARD_STARTING_POSITIONS: (k for k,v of adjacency_graphs.qwerty).length\n  KEYPAD_STARTING_POSITIONS: (k for k,v of adjacency_graphs.keypad).length\n\n  spatial_guesses: (match) ->\n    if match.graph in ['qwerty', 'dvorak']\n      s = @KEYBOARD_STARTING_POSITIONS\n      d = @KEYBOARD_AVERAGE_DEGREE\n    else\n      s = @KEYPAD_STARTING_POSITIONS\n      d = @KEYPAD_AVERAGE_DEGREE\n    guesses = 0\n    L = match.token.length\n    t = match.turns\n    # estimate the number of possible patterns w/ length L or less with t turns or less.\n    for i in [2..L]\n      possible_turns = Math.min(t, i - 1)\n      for j in [1..possible_turns]\n        guesses += @nCk(i - 1, j - 1) * s * Math.pow(d, j)\n    # add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n    # math is similar to extra guesses of l33t substitutions in dictionary matches.\n    if match.shifted_count\n      S = match.shifted_count\n      U = match.token.length - match.shifted_count # unshifted count\n      if S == 0 or U == 0\n        guesses *= 2\n      else\n        shifted_variations = 0\n        shifted_variations += @nCk(S + U, i) for i in [1..Math.min(S, U)]\n        guesses *= shifted_variations\n    guesses\n\n  dictionary_guesses: (match) ->\n    match.base_guesses = match.rank # keep these as properties for display purposes\n    match.uppercase_variations = @uppercase_variations match\n    match.l33t_variations = @l33t_variations match\n    reversed_variations = match.reversed and 2 or 1\n    match.base_guesses * match.uppercase_variations * match.l33t_variations * reversed_variations\n\n  START_UPPER: /^[A-Z][^A-Z]+$/\n  END_UPPER: /^[^A-Z]+[A-Z]$/\n  ALL_UPPER: /^[^a-z]+$/\n  ALL_LOWER: /^[^A-Z]+$/\n\n  uppercase_variations: (match) ->\n    word = match.token\n    return 1 if word.match(@ALL_LOWER) or word.toLowerCase() == word\n    # a capitalized word is the most common capitalization scheme,\n    # so it only doubles the search space (uncapitalized + capitalized).\n    # allcaps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n    for regex in [@START_UPPER, @END_UPPER, @ALL_UPPER]\n      return 2 if word.match regex\n    # otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n    # with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n    # the number of ways to lowercase U+L letters with L lowercase letters or less.\n    U = (chr for chr in word.split('') when chr.match /[A-Z]/).length\n    L = (chr for chr in word.split('') when chr.match /[a-z]/).length\n    variations = 0\n    variations += @nCk(U + L, i) for i in [1..Math.min(U, L)]\n    variations\n\n  l33t_variations: (match) ->\n    return 1 if not match.l33t\n    variations = 1\n    for subbed, unsubbed of match.sub\n      # lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n      chrs = match.token.toLowerCase().split('')\n      S = (chr for chr in chrs when chr == subbed).length   # num of subbed chars\n      U = (chr for chr in chrs when chr == unsubbed).length # num of unsubbed chars\n      if S == 0 or U == 0\n        # for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n        # treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n        # unsubbed.)\n        variations *= 2\n      else\n        # this case is similar to capitalization:\n        # with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n        p = Math.min(U, S)\n        possibilities = 0\n        possibilities += @nCk(U + S, i) for i in [1..p]\n        variations *= possibilities\n    variations\n\n  # utilities --------------------------------------------------------------------\n\nmodule.exports = scoring\n"
  ]
}